import { Injectable, UnauthorizedException, BadRequestException, Logger } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { PrismaService } from '../../common/prisma/prisma.service';
import * as bcrypt from 'bcryptjs';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class AuthService {
  private readonly logger = new Logger(AuthService.name);

  constructor(
    private prisma: PrismaService,
    private jwtService: JwtService,
  ) {}

  async validateStaff(email: string, password: string) {
    const staff = await this.prisma.staff.findUnique({
      where: { email },
    });

    if (!staff) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const isPasswordValid = await bcrypt.compare(password, staff.passwordHash);
    if (!isPasswordValid) {
      throw new UnauthorizedException('Invalid credentials');
    }

    if (!staff.isActive) {
      throw new UnauthorizedException('Staff account is inactive');
    }

    return staff;
  }

  async login(staff: any) {
    const payload = {
      sub: staff.id,
      email: staff.email,
      role: staff.role,
      resortId: staff.resortId,
    };

    const accessToken = this.jwtService.sign(payload);
    const refreshToken = this.jwtService.sign(payload, { expiresIn: '7d' });

    // Update last login
    await this.prisma.staff.update({
      where: { id: staff.id },
      data: { lastLoginAt: new Date() },
    });

    return {
      accessToken,
      refreshToken,
      staff: {
        id: staff.id,
        email: staff.email,
        name: staff.name,
        role: staff.role,
        resortId: staff.resortId,
      },
    };
  }

  async createGuestSession(roomId: string) {
    const room = await this.prisma.room.findUnique({
      where: { id: roomId },
    });

    if (!room) {
      throw new BadRequestException('Room not found');
    }

    const sessionToken = uuidv4();
    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

    const session = await this.prisma.guestSession.create({
      data: {
        roomId,
        sessionToken,
        expiresAt,
      },
    });

    return {
      sessionToken,
      roomId,
      expiresAt,
    };
  }

  async validateGuestSession(sessionToken: string) {
    const session = await this.prisma.guestSession.findUnique({
      where: { sessionToken },
      include: { room: true },
    });

    if (!session) {
      throw new UnauthorizedException('Invalid session');
    }

    if (!session.isActive) {
      throw new UnauthorizedException('Session is inactive');
    }

    if (new Date() > session.expiresAt) {
      throw new UnauthorizedException('Session expired');
    }

    return session;
  }

  async refreshToken(refreshToken: string) {
    try {
      const payload = this.jwtService.verify(refreshToken);
      const newAccessToken = this.jwtService.sign({
        sub: payload.sub,
        email: payload.email,
        role: payload.role,
        resortId: payload.resortId,
      });

      return { accessToken: newAccessToken };
    } catch (error) {
      throw new UnauthorizedException('Invalid refresh token');
    }
  }
}
